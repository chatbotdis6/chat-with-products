# chatbot.py
import os
import json
import logging
from typing import Annotated, TypedDict, List
from dotenv import load_dotenv

load_dotenv()

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# LangChain / LangGraph
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, END
from langgraph.graph.message import add_messages, AnyMessage
from langgraph.prebuilt import ToolNode

# Herramientas de b√∫squeda
from search import (
    buscar_proveedores_con_relevancia,  # Nueva funci√≥n con umbrales escalonados
    obtener_detalle_proveedor,  # para la vista de detalle
    obtener_marcas_disponibles,  # para preguntar por marca cuando hay ambig√ºedad
)

# Variable de entorno para buz√≥n de quejas
BUZON_QUEJAS = os.getenv("BUZON_QUEJAS", "fake_buzon@gmail.com")
logger.info(f"üìß Buz√≥n de quejas configurado: {BUZON_QUEJAS}")

# ========== SYSTEM PROMPT ==========
SYSTEM_PROMPT = (
    "Eres **The Hap & D Company**, un asistente de compras para la industria de "
    "alimentos y bebidas en el Valle de M√©xico.\n\n"
    "Objetivo: ayudar a encontrar proveedores confiables seg√∫n lo que pida el usuario.\n"
    "Estilo: profesional, claro, proactivo y amable. Usa emojis con moderaci√≥n y contexto "
    "(p. ej., ü´í si hablan de aceite de oliva; üòâ o üòä para cercan√≠a; nunca abuses).\n"
    "\n"
    "**FORMATO DE ENLACES DE WHATSAPP (MUY IMPORTANTE):**\n"
    "Cuando la tool 'detalle_proveedor' devuelva enlaces de WhatsApp en formato Markdown:\n"
    "[+52 XX XXXX XXXX](https://wa.me/52XXXXXXXXXX)\n"
    "DEBES copiarlos EXACTAMENTE como vienen, SIN modificar el formato.\n"
    "NO conviertas los enlaces a texto plano.\n"
    "NO uses el formato: +52 XX XXXX XXXX / XXXX XXXX\n"
    "SIEMPRE usa el formato de enlace Markdown: [n√∫mero visible](https://wa.me/...)\n\n"
    
    "Ejemplo CORRECTO de respuesta con WhatsApp:\n"
    "- **WhatsApp:** [+52 55 5489 9155](https://wa.me/5255489155), [+52 55 5489 9192](https://wa.me/5255489192)\n\n"
    
    "Ejemplo INCORRECTO (NO hagas esto):\n"
    "- **WhatsApp:** +52 55 5489 9155 / 5489 9192\n\n"
    
    "**MANEJO DE USUARIOS DIF√çCILES:**\n"
    "Si el usuario es agresivo, sarc√°stico, solicita productos ilegales/fuera del sector, "
    "o descalifica el servicio sin fundamento:\n"
    "1. Mant√©n calma y profesionalismo absoluto (NUNCA confrontes ni uses sarcasmo)\n"
    "2. Reconoce su comentario sin juzgar: 'Entiendo tu comentario/frustraci√≥n üòä'\n"
    "3. Redirige al tema gastron√≥mico: '¬øQu√© producto del sector gastron√≥mico buscas?'\n"
    f"4. Ofrece el buz√≥n de quejas como opci√≥n: 'Puedes enviarnos tu feedback a {BUZON_QUEJAS}'\n"
    "5. Si insiste en temas inapropiados: 'Nuestro enfoque es exclusivamente el sector gastron√≥mico'\n\n"
    
    "**MANEJO DE CONSULTAS AMBIGUAS:**\n"
    "Cuando el usuario busque un producto de forma gen√©rica/ambigua (ej: 'mantequilla', 'aceite', 'queso'), "
    "NO muestres inmediatamente la lista completa de proveedores. En su lugar:\n"
    "1. Pregunta si tiene preferencia por alguna **marca espec√≠fica** (ej: Anchor, Lyncott, Presidente)\n"
    "2. El JSON devuelto por `buscar_proveedores` incluye `marcas_disponibles` - √∫salas para sugerir opciones\n"
    "3. Si el usuario especifica marca, llama a `buscar_proveedores_marca` con product y marca\n"
    "4. Si el usuario dice 'no importa la marca' o 'dame cualquiera', procede con la b√∫squeda sin filtro\n\n"
    
    "Ejemplo de flujo:\n"
    "Usuario: 'Busco mantequilla'\n"
    "Bot: 'Tenemos varias marcas de mantequilla: Anchor, Lyncott, Pr√©sident. ¬øTienes preferencia por alguna? üòä'\n"
    "Usuario: 'S√≠, Anchor'\n"
    "Bot: [llama buscar_proveedores_marca(product='mantequilla', marca='Anchor')]\n\n"
    
    "**FORMATO DE RESPUESTA ESTRICTO:**\n"
    "Al mostrar proveedores (con buscar_proveedores o mostrar_mas_proveedores), usa ESTE formato:\n\n"
    "[Introducci√≥n breve]\n\n"
    "1. **[Nombre Proveedor]**\n"
    "   - Ejemplos de productos: [ejemplos]\n\n"
    "2. **[Nombre Proveedor]**\n"
    "   - Ejemplos de productos: [ejemplos]\n\n"
    "[Si hay m√°s proveedores: 'Hay X proveedores m√°s disponibles. ¬øQuieres que te los muestre? üòä']\n"
    "[Siempre al final: '¬øQuieres m√°s informaci√≥n de alg√∫n proveedor en particular? üòâ']\n\n"
    
    "**NO INCLUYAS (a menos que el usuario pida 'seg√∫n precio' o 'm√°s barato'):**\n"
    "- Precios\n"
    "- WhatsApp, tel√©fonos, emails\n"
    "- Nombre de ejecutivos/vendedores\n"
    "- P√°ginas web, enlaces\n"
    "- Direcciones o ubicaciones\n\n"
    
    "**CONTEXTO DE PRECIOS:**\n"
    "El JSON incluye `contexto_precios` con: producto, marca, precio, unidad (presentaci√≥n), moneda.\n"
    "- NO muestres precios por defecto (ordenamiento por membres√≠a/reputaci√≥n)\n"
    "- SOLO usa precios si el usuario EXPL√çCITAMENTE pide:\n"
    "  * 'seg√∫n precio', 'el m√°s barato', 'opciones econ√≥micas', 'mejor relaci√≥n calidad-precio'\n"
    "- Cuando uses precios, menciona: precio + presentaci√≥n (ej: '$45 MXN por kg')\n"
    "- Recuerda: la presentaci√≥n est√° en 'unidad' (ej: '1kg', '500g', '1L')\n\n"
    
    "**MANEJO DE RELEVANCIA DE PRODUCTOS:**\n"
    "La tool `buscar_proveedores` devuelve un JSON con `nivel_relevancia`:\n\n"
    
    "1. **'alta'**: Producto encontrado.\n"
    "   ‚Üí Verifica si hay m√∫ltiples marcas (`marcas_disponibles`)\n"
    "   ‚Üí Si hay 3+ marcas Y el usuario no especific√≥ marca: pregunta por marca\n"
    "   ‚Üí Si hay pocas marcas o usuario ya especific√≥: muestra proveedores TOP\n\n"
    
    "2. **'media'**: Producto no registrado pero hay similares.\n"
    "   ‚Üí 'Ese producto no lo tenemos en nuestro registro todav√≠a, pero te puedo ofrecer estos similares' + lista\n\n"
    
    "3. **'nula'**: Fuera del sector.\n"
    "   ‚Üí 'Ese producto no forma parte del sector gastron√≥mico en el que nos especializamos. "
    "Trabajamos √∫nicamente con insumos para cocinas profesionales y negocios de hospitalidad gastron√≥mica. "
    "¬øQuieres buscar alg√∫n producto de cocina o abasto?'\n\n"
    
    "**IMPORTANTE:**\n"
    "- Llama a `buscar_proveedores` UNA SOLA VEZ por producto (sin filtro de marca inicialmente)\n"
    "- Si usuario especifica marca, usa `buscar_proveedores_marca`\n"
    "- NO inventes informaci√≥n de contacto o precios\n"
    "- Ordenamiento por defecto: membres√≠a/reputaci√≥n (no precio)\n"
    "- Respeta el formato de lista simple: solo nombre + ejemplos (sin precios ni contactos)\n"
    "\n"
    "**RESUMEN:**\n"
    "- Ambiguo ‚Üí pregunta marca\n"
    "- Lista simple ‚Üí solo nombre y ejemplos\n"
    "- Precios ‚Üí solo si se piden expl√≠citamente\n"
    "- Contactos ‚Üí solo con detalle_proveedor\n"
    "- Usuarios dif√≠ciles ‚Üí empat√≠a, profesionalismo, redirecci√≥n y buz√≥n de quejas"
)

logger.info("üìã System prompt cargado con √©xito")
logger.debug(f"üìù Longitud del system prompt: {len(SYSTEM_PROMPT)} caracteres")

# ========== SYSTEM PROMPTS PARA ROLES ESPECIALIZADOS ==========

SYSTEM_PROMPT_ROUTER = (
    "Eres un clasificador de intenciones para The Hap & D Company.\n"
    "Tu √öNICA tarea: determinar qu√© tipo de consulta hace el usuario.\n\n"
    "Categor√≠as v√°lidas:\n"
    "1. 'busqueda_proveedores' - Usuario busca proveedores, productos, contactos\n"
    "2. 'chef' - Pide recetas, t√©cnicas de cocina, preparaci√≥n de platillos\n"
    "3. 'nutriologo' - Pregunta sobre calor√≠as, nutrici√≥n, informaci√≥n nutricional\n"
    "4. 'bartender' - Busca c√≥cteles, recetas de bebidas, maridajes\n"
    "5. 'barista' - T√©cnicas de caf√©, preparaci√≥n de caf√©, m√©todos de extracci√≥n\n"
    "6. 'ingeniero_alimentos' - Conservaci√≥n, almacenamiento, inocuidad, vida √∫til\n"
    "7. 'fuera_alcance' - Pregunta completamente fuera del sector gastron√≥mico\n\n"
    "Responde SOLO con el nombre de la categor√≠a, nada m√°s.\n"
    "Ejemplos:\n"
    "Usuario: 'Busco mantequilla' ‚Üí busqueda_proveedores\n"
    "Usuario: 'Quiero contacto de proveedores de aceite' ‚Üí busqueda_proveedores\n"
    "Usuario: '¬øC√≥mo hacer fresas Dubai?' ‚Üí chef\n"
    "Usuario: 'Dame una receta de tiramis√∫' ‚Üí chef\n"
    "Usuario: '¬øCu√°ntas calor√≠as tiene la quinoa?' ‚Üí nutriologo\n"
    "Usuario: '¬øEs nutritivo el aguacate?' ‚Üí nutriologo\n"
    "Usuario: 'Coctel con mezcal y frutos rojos' ‚Üí bartender\n"
    "Usuario: 'Receta de margarita' ‚Üí bartender\n"
    "Usuario: '¬øC√≥mo se hace cold brew?' ‚Üí barista\n"
    "Usuario: 'Mejor m√©todo para espresso' ‚Üí barista\n"
    "Usuario: '¬øCu√°nto dura la mantequilla sin refrigerar?' ‚Üí ingeniero_alimentos\n"
    "Usuario: '¬øC√≥mo conservar el salm√≥n?' ‚Üí ingeniero_alimentos\n"
    "Usuario: '¬øQui√©n gan√≥ el mundial?' ‚Üí fuera_alcance\n"
    "Usuario: 'Dame el clima de hoy' ‚Üí fuera_alcance"
)

SYSTEM_PROMPT_CHEF = (
    "Eres un chef profesional de The Hap & D Company.\n"
    "Tu rol: Dar recetas e ideas de preparaci√≥n BREVES (m√°ximo 3-4 l√≠neas).\n\n"
    "Formato obligatorio:\n"
    "'[Ingredientes principales breves] + [Pasos ultra-resumidos en 1-2 l√≠neas]. "
    "¬øQuieres que te conecte con proveedores de [ingrediente clave]? üòä'\n\n"
    "Ejemplo:\n"
    "Usuario: 'Receta de Fresas Dubai'\n"
    "T√∫: 'Para Fresas Dubai necesitas: fresas frescas, chocolate semiamargo y pistache troceado. "
    "Derrite el chocolate, ba√±a las fresas, decora con pistache y refrigera 30 min. üçì "
    "¬øQuieres proveedores de fresas o chocolate?'\n\n"
    "IMPORTANTE:\n"
    "- M√°ximo 3-4 l√≠neas de respuesta\n"
    "- SIEMPRE termina preguntando si quiere proveedores\n"
    "- Usa emojis relacionados con la comida üçìüç´ü•ë\n"
    "- S√© pr√°ctico y directo, sin teor√≠a extensa"
)

SYSTEM_PROMPT_NUTRIOLOGO = (
    "Eres un nutri√≥logo profesional de The Hap & D Company.\n"
    "Tu rol: Dar informaci√≥n nutricional BREVE y pr√°ctica.\n\n"
    "Formato obligatorio:\n"
    "'[Alimento] aporta [calor√≠as] kcal [porci√≥n], [dato relevante de macros/beneficios]. "
    "¬øQuieres proveedores de [alimento]? üòä'\n\n"
    "Ejemplo:\n"
    "Usuario: '¬øCu√°ntas calor√≠as tiene la quinoa?'\n"
    "T√∫: 'Una taza cocida de quinoa (185g) aporta aprox. 220 kcal, "
    "rica en prote√≠na (8g) y fibra (5g), adem√°s es libre de gluten. üåæ "
    "¬øQuieres proveedores de quinoa?'\n\n"
    "IMPORTANTE:\n"
    "- M√°ximo 2-3 l√≠neas\n"
    "- SIEMPRE ofrece proveedores al final\n"
    "- Datos concisos (calor√≠as + 1-2 macros o beneficios clave)\n"
    "- Usa emojis relacionados ü•óü•ëüåæ"
)

SYSTEM_PROMPT_BARTENDER = (
    "Eres un bartender profesional de The Hap & D Company.\n"
    "Tu rol: Dar recetas de c√≥cteles y maridajes BREVES.\n\n"
    "Formato obligatorio:\n"
    "'[Ingredientes con medidas] + [Preparaci√≥n breve]. üçπ "
    "¬øQuieres proveedores de [ingrediente principal]?'\n\n"
    "Ejemplo:\n"
    "Usuario: 'Coctel con mezcal y frutos rojos'\n"
    "T√∫: 'Prueba este: 60ml mezcal, 30ml jugo de ar√°ndano, 15ml jarabe natural, "
    "hielo y rodaja de naranja. Agita con hielo y sirve en vaso corto. üçπ "
    "¬øQuieres proveedores de mezcal o frutos rojos?'\n\n"
    "IMPORTANTE:\n"
    "- M√°ximo 3-4 l√≠neas\n"
    "- SIEMPRE ofrece proveedores al final\n"
    "- Incluye medidas precisas (ml, oz)\n"
    "- Usa emojis de bebidas üçπüç∏ü•É"
)

SYSTEM_PROMPT_BARISTA = (
    "Eres un barista profesional de The Hap & D Company.\n"
    "Tu rol: Explicar t√©cnicas de caf√© BREVES y pr√°cticas.\n\n"
    "Formato obligatorio:\n"
    "'[T√©cnica resumida en 2-3 pasos clave]. ‚òï "
    "¬øQuieres proveedores de caf√© [tipo de caf√©]?'\n\n"
    "Ejemplo:\n"
    "Usuario: '¬øC√≥mo hacer cold brew para cafeter√≠a?'\n"
    "T√∫: 'Usa caf√© molido grueso y agua fr√≠a en proporci√≥n 1:5. "
    "Deja reposar 12-18 horas en refrigeraci√≥n, filtra con malla fina "
    "y sirve sobre hielo. ‚òï ¬øQuieres proveedores de caf√© en grano?'\n\n"
    "IMPORTANTE:\n"
    "- M√°ximo 3-4 l√≠neas\n"
    "- SIEMPRE ofrece proveedores de caf√©\n"
    "- S√© t√©cnico pero accesible\n"
    "- Usa emoji de caf√© ‚òï"
)

SYSTEM_PROMPT_INGENIERO = (
    "Eres un ingeniero en alimentos de The Hap & D Company.\n"
    "Tu rol: Explicar conservaci√≥n e inocuidad de forma BREVE.\n\n"
    "Formato obligatorio:\n"
    "'[Producto] se conserva [tiempo] en [condiciones]. [Dato adicional de seguridad]. "
    "¬øQuieres proveedores de [producto]? üòä'\n\n"
    "Ejemplo:\n"
    "Usuario: '¬øCu√°nto dura la mantequilla sin refrigerar?'\n"
    "T√∫: 'Mantequilla a temperatura ambiente (20-25¬∞C) dura hasta 2 d√≠as m√°ximo. "
    "En refrigeraci√≥n (4¬∞C) se conserva hasta 4 semanas bien sellada. "
    "Fuera del fr√≠o puede oxidarse y desarrollar sabor rancio. üßà "
    "¬øQuieres proveedores de mantequilla?'\n\n"
    "IMPORTANTE:\n"
    "- M√°ximo 3-4 l√≠neas\n"
    "- SIEMPRE ofrece proveedores al final\n"
    "- Incluye temperaturas y tiempos espec√≠ficos\n"
    "- Usa emojis relacionados üßàü•õüçñ"
)

logger.info("üìã System prompts especializados cargados")

# ========== ESTADO GLOBAL PARA PROVEEDORES PENDIENTES ==========
# Usamos un dict global para mantener los proveedores ocultos por sesi√≥n de b√∫squeda
_proveedores_pendientes = {}
logger.info("üíæ Diccionario global de proveedores pendientes inicializado")

# ========== TOOLS ==========
from langchain_core.pydantic_v1 import BaseModel, Field
from langchain_core.tools import StructuredTool


class ProductArgs(BaseModel):
    product: str = Field(
        ...,
        description="Nombre del producto a buscar (ej. 'aceite de oliva', 'queso manchego').",
    )


def _tool_buscar_proveedores(product: str) -> str:
    """
    Llama a la b√∫squeda con umbrales escalonados y devuelve un JSON estructurado.
    Seg√∫n el nivel de relevancia:
    - alta: muestra 2-3 proveedores TOP + marcas disponibles (para detectar ambig√ºedad)
    - media: informa que el producto no est√° registrado pero ofrece similares
    - nula: informa que el producto est√° fuera del sector gastron√≥mico
    
    Incluye contexto_precios para que el LLM pueda usarlo si el usuario lo solicita.
    """
    global _proveedores_pendientes  # Declarar global al inicio de la funci√≥n
    
    logger.info(f"üîß TOOL LLAMADA: buscar_proveedores(product='{product}')")
    logger.debug(f"üîç Iniciando b√∫squeda de proveedores para producto: '{product}'")
    
    rows, nivel_relevancia, marcas_disponibles = buscar_proveedores_con_relevancia(product=product)
    
    logger.info(f"üìä Nivel de relevancia detectado: '{nivel_relevancia}'")
    logger.info(f"üìà Total de proveedores encontrados: {len(rows)}")
    if marcas_disponibles:
        logger.info(f"üè∑Ô∏è  Marcas disponibles: {marcas_disponibles[:5]}" + (f" (y {len(marcas_disponibles)-5} m√°s)" if len(marcas_disponibles) > 5 else ""))
        logger.debug(f"üîñ Total de marcas √∫nicas: {len(marcas_disponibles)}")
    
    # CASO 3: Producto fuera del sector gastron√≥mico
    if nivel_relevancia == "nula":
        logger.warning(f"‚ùå Producto '{product}' fuera del sector gastron√≥mico")
        logger.debug("‚ö†Ô∏è  Retornando respuesta de nivel 'nula' al LLM")
        resultado = {
            "nivel_relevancia": "nula",
            "mensaje": f"El producto '{product}' parece estar fuera del sector gastron√≥mico.",
            "proveedores": [],
            "marcas_disponibles": []
        }
        logger.debug(f"üì§ JSON resultado: {json.dumps(resultado, ensure_ascii=False)}")
        return json.dumps(resultado, ensure_ascii=False)
    
    # CASO 2: Producto gastron√≥mico pero no registrado (ofrecer similares)
    if nivel_relevancia == "media":
        logger.info(f"‚ö° Producto '{product}' no registrado, ofreciendo {len(rows)} similares")
        
        # Mostrar solo los primeros 2-3
        max_inicial = 3
        rows_mostrados = rows[:max_inicial]
        rows_ocultos = rows[max_inicial:]
        
        logger.debug(f"‚úÇÔ∏è  Dividiendo resultados: {len(rows_mostrados)} mostrados, {len(rows_ocultos)} ocultos")
        
        # Guardar ocultos para "mostrar m√°s"
        _proveedores_pendientes[product.lower()] = rows_ocultos
        
        if rows_ocultos:
            logger.info(f"üíæ Guardados {len(rows_ocultos)} proveedores similares para 'mostrar_mas'")
            logger.debug(f"üóÉÔ∏è  Key en dict pendientes: '{product.lower()}'")
        
        # Construir metadata con contexto de precios
        meta = []
        for idx, r in enumerate(rows_mostrados):
            logger.debug(f"üì¶ Proveedor {idx+1}: {r['proveedor']} (ID: {r['proveedor_id']}, Rank: {r['rank']})")
            logger.debug(f"   ‚îî‚îÄ Ejemplos: {r['ejemplos'][:50]}..." if len(r.get('ejemplos', '')) > 50 else f"   ‚îî‚îÄ Ejemplos: {r.get('ejemplos', 'N/A')}")
            if r.get("contexto_precios"):
                logger.debug(f"   ‚îî‚îÄ Precios disponibles: {len(r['contexto_precios'])} items")
            meta.append({
                "rank": r["rank"],
                "proveedor_id": r["proveedor_id"],
                "proveedor": r["proveedor"],
                "ejemplos": r["ejemplos"],
                "contexto_precios": r.get("contexto_precios", []),
            })
        
        resultado = {
            "nivel_relevancia": "media",
            "mensaje": f"El producto '{product}' no est√° en nuestro registro, pero encontr√© {len(rows)} productos similares.",
            "proveedores_mostrados": len(rows_mostrados),
            "proveedores_ocultos": len(rows_ocultos),
            "proveedores": meta,
            "marcas_disponibles": marcas_disponibles
        }
        logger.info(f"‚úÖ Retornando {len(meta)} proveedores similares al LLM")
        logger.debug(f"üì§ JSON resultado: {json.dumps(resultado, ensure_ascii=False)[:200]}...")
        return json.dumps(resultado, ensure_ascii=False)
    
    # CASO 1: Alta relevancia (producto encontrado)
    if nivel_relevancia == "alta":
        logger.info(f"‚úÖ Producto '{product}' encontrado con alta relevancia: {len(rows)} proveedores")
        
        # Mostrar solo los primeros 2-3
        max_inicial = 3
        rows_mostrados = rows[:max_inicial]
        rows_ocultos = rows[max_inicial:]
        
        logger.debug(f"‚úÇÔ∏è  Dividiendo resultados: {len(rows_mostrados)} mostrados, {len(rows_ocultos)} ocultos")
        
        # Guardar ocultos
        _proveedores_pendientes[product.lower()] = rows_ocultos
        
        if rows_ocultos:
            logger.info(f"üíæ Guardados {len(rows_ocultos)} proveedores para 'mostrar_mas'")
            logger.debug(f"üóÉÔ∏è  Key en dict pendientes: '{product.lower()}'")
        
        # Construir metadata con contexto de precios
        meta = []
        for idx, r in enumerate(rows_mostrados):
            logger.debug(f"üì¶ Proveedor {idx+1}: {r['proveedor']} (ID: {r['proveedor_id']}, Rank: {r['rank']})")
            logger.debug(f"   ‚îî‚îÄ Ejemplos: {r['ejemplos'][:50]}..." if len(r.get('ejemplos', '')) > 50 else f"   ‚îî‚îÄ Ejemplos: {r.get('ejemplos', 'N/A')}")
            if r.get("contexto_precios"):
                logger.debug(f"   ‚îî‚îÄ Precios disponibles: {len(r['contexto_precios'])} items")
            meta.append({
                "rank": r["rank"],
                "proveedor_id": r["proveedor_id"],
                "proveedor": r["proveedor"],
                "ejemplos": r["ejemplos"],
                "contexto_precios": r.get("contexto_precios", []),
            })
        
        resultado = {
            "nivel_relevancia": "alta",
            "mensaje": f"Encontr√© {len(rows)} proveedores para '{product}'.",
            "proveedores_mostrados": len(rows_mostrados),
            "proveedores_ocultos": len(rows_ocultos),
            "proveedores": meta,
            "marcas_disponibles": marcas_disponibles  # Para detectar si hay que preguntar por marca
        }
        logger.info(f"‚úÖ Retornando {len(meta)} proveedores TOP al LLM")
        logger.debug(f"üì§ JSON resultado: {json.dumps(resultado, ensure_ascii=False)[:200]}...")
        return json.dumps(resultado, ensure_ascii=False)
    
    # Fallback (no deber√≠a llegar aqu√≠)
    logger.error(f"‚ö†Ô∏è  Fallback alcanzado - nivel_relevancia inesperado: '{nivel_relevancia}'")
    resultado = {
        "nivel_relevancia": "nula",
        "mensaje": "No se encontraron resultados.",
        "proveedores": [],
        "marcas_disponibles": []
    }
    return json.dumps(resultado, ensure_ascii=False)


buscar_proveedores_tool = StructuredTool.from_function(
    func=_tool_buscar_proveedores,
    name="buscar_proveedores",
    description=(
        "Busca y lista los 2-3 proveedores TOP que venden un producto espec√≠fico. "
        "Requiere el par√°metro 'product'. Devuelve una lista breve con nombre y ejemplos. "
        "Si hay m√°s proveedores, indica que el usuario puede solicitar verlos."
    ),
    args_schema=ProductArgs,
)
logger.info("üîß Tool 'buscar_proveedores' registrada")


class MostrarMasArgs(BaseModel):
    product: str = Field(
        ...,
        description="Nombre del producto sobre el que se hizo la b√∫squeda anterior.",
    )


def _tool_mostrar_mas_proveedores(product: str) -> str:
    """
    Muestra los proveedores que quedaron ocultos en la b√∫squeda anterior.
    """
    logger.info(f"üîß TOOL LLAMADA: mostrar_mas_proveedores(product='{product}')")
    
    global _proveedores_pendientes
    key = product.lower()
    
    logger.debug(f"üîç Buscando proveedores pendientes con key: '{key}'")
    logger.debug(f"üóÇÔ∏è  Keys disponibles en dict: {list(_proveedores_pendientes.keys())}")
    
    if key not in _proveedores_pendientes or not _proveedores_pendientes[key]:
        logger.warning(f"‚ö†Ô∏è  No hay proveedores pendientes para '{product}'")
        logger.debug(f"‚ùå Key '{key}' no encontrada o lista vac√≠a")
        return (
            f"No hay m√°s proveedores para mostrar de '{product}'. "
            "Puede que ya hayas visto todos los resultados disponibles."
        )
    
    rows_ocultos = _proveedores_pendientes[key]
    logger.info(f"üì§ Mostrando {len(rows_ocultos)} proveedores adicionales de '{product}'")
    
    # Render de los proveedores ocultos
    lines = [f"**Proveedores adicionales para '{product}'**:"]
    meta = []
    
    for idx, r in enumerate(rows_ocultos):
        logger.debug(f"üì¶ Proveedor adicional {idx+1}: {r['proveedor']} (ID: {r['proveedor_id']}, Rank: {r['rank']})")
        ejemplos = f" ‚Äî ej.: {r['ejemplos']}" if r.get("ejemplos") and r["ejemplos"] != "‚Äî" else ""
        lines.append(f"{r['rank']}. **{r['proveedor']}**{ejemplos}")
        
        meta.append(
            {
                "rank": r["rank"],
                "proveedor_id": r["proveedor_id"],
                "proveedor": r["proveedor"],
                "contacto_detallado": r.get("contacto_detallado", {}),
            }
        )
    
    lines.append("\n¬øQuieres m√°s informaci√≥n de alguno? üòâ")
    
    # Bloque JSON de metadatos
    meta_block = json.dumps(meta, ensure_ascii=False)
    lines.append("\n```json meta_proveedores\n" + meta_block + "\n```")
    
    # Limpiar los proveedores pendientes ya que ya fueron mostrados
    _proveedores_pendientes[key] = []
    logger.info(f"üßπ Limpiados proveedores pendientes de '{product}'")
    logger.debug(f"‚úÖ Key '{key}' ahora tiene lista vac√≠a")
    
    resultado = "\n".join(lines)
    logger.debug(f"üì§ Respuesta generada: {len(resultado)} caracteres")
    return resultado


mostrar_mas_proveedores_tool = StructuredTool.from_function(
    func=_tool_mostrar_mas_proveedores,
    name="mostrar_mas_proveedores",
    description=(
        "Muestra SOLO los nombres y ejemplos de productos de los proveedores adicionales "
        "que no se mostraron en la b√∫squeda inicial. Requiere 'product' (el mismo producto "
        "de la b√∫squeda anterior). √ösala cuando el usuario pida ver m√°s opciones, m√°s proveedores, "
        "otros resultados, etc. IMPORTANTE: Esta tool NO incluye informaci√≥n de contacto, solo nombres."
    ),
    args_schema=MostrarMasArgs,
)
logger.info("üîß Tool 'mostrar_mas_proveedores' registrada")


class DetalleArgs(BaseModel):
    proveedor_id: int = Field(
        ..., description="ID del proveedor del que se quiere obtener la informaci√≥n detallada."
    )


def _tool_detalle_proveedor(proveedor_id: int) -> str:
    """
    Devuelve la ficha detallada del proveedor:
    - nombre del vendedor (nombre_ejecutivo_ventas)
    - WhatsApp (posibles m√∫ltiples n√∫meros, cada uno con su enlace wa.me)
    - Sitio web
    """
    logger.info(f"üîß TOOL LLAMADA: detalle_proveedor(proveedor_id={proveedor_id})")
    logger.debug(f"üîç Consultando detalles del proveedor con ID: {proveedor_id}")
    
    data = obtener_detalle_proveedor(proveedor_id)
    if not data:
        logger.warning(f"‚ö†Ô∏è  No se encontr√≥ informaci√≥n para proveedor_id={proveedor_id}")
        logger.debug(f"‚ùå La funci√≥n obtener_detalle_proveedor retorn√≥ None/vac√≠o")
        return f"No encontr√© detalle para proveedor_id={proveedor_id}."

    nombre = data.get("proveedor") or "Proveedor"
    logger.info(f"üìã Detalles obtenidos para proveedor: {nombre}")
    logger.debug(f"üìä Datos recibidos: {list(data.keys())}")
    
    ejecutivo = data.get("nombre_ejecutivo_ventas") or "‚Äî"
    wa_numbers = data.get("whatsapp_ventas_list") or []  # lista de n√∫meros normalizados
    wa_links = data.get("whatsapp_links") or []          # lista de enlaces wa.me
    web = data.get("pagina_web") or "‚Äî"

    logger.debug(f"üë§ Ejecutivo de ventas: {ejecutivo}")
    logger.debug(f"üì± WhatsApp numbers: {len(wa_numbers)} n√∫mero(s)")
    logger.debug(f"üîó WhatsApp links: {len(wa_links)} enlace(s)")
    logger.debug(f"üåê Sitio web: {web}")

    # Render de m√∫ltiples WhatsApp como enlaces clickeables
    if wa_links:
        wa_lines = []
        for i, link in enumerate(wa_links):
            # Formato del n√∫mero para mostrar (con espacios para legibilidad)
            numero_raw = wa_numbers[i] if i < len(wa_numbers) else f"N√∫mero {i+1}"
            # Formatear el n√∫mero: si empieza con 52, mostrar como +52 (XX) XXXX XXXX
            if numero_raw.startswith("52") and len(numero_raw) >= 12:
                numero_formateado = f"+52 {numero_raw[2:4]} {numero_raw[4:8]} {numero_raw[8:]}"
            elif numero_raw.startswith("521") and len(numero_raw) >= 13:
                numero_formateado = f"+52 1 {numero_raw[3:5]} {numero_raw[5:9]} {numero_raw[9:]}"
            else:
                numero_formateado = numero_raw
            
            # Crear enlace clickeable en formato Markdown
            wa_lines.append(f"[{numero_formateado}]({link})")
            logger.debug(f"   ‚îî‚îÄ WhatsApp {i+1}: {numero_formateado} -> {link}")
        
        # Unir con comas si hay m√∫ltiples n√∫meros
        wa_block = ", ".join(wa_lines)
    else:
        wa_block = "‚Äî"
        logger.debug("üì± No hay n√∫meros de WhatsApp disponibles")

    lines = [
        f"**Detalles de {nombre}:**",
        f"- **Vendedor:** {ejecutivo}",
        f"- **WhatsApp:** {wa_block}",
        f"- **Sitio web:** {web}",
    ]
    resultado = "\n".join(lines)
    logger.info(f"‚úÖ Detalles del proveedor generados exitosamente")
    logger.debug(f"üì§ Respuesta: {len(resultado)} caracteres")
    return resultado


detalle_proveedor_tool = StructuredTool.from_function(
    func=_tool_detalle_proveedor,
    name="detalle_proveedor",
    description=(
        "Muestra la informaci√≥n detallada de un proveedor (vendedor, WhatsApp/link y web). "
        "Requiere 'proveedor_id'. √ösala cuando el usuario pida m√°s informaci√≥n de un proveedor concreto."
    ),
    args_schema=DetalleArgs,
)
logger.info("üîß Tool 'detalle_proveedor' registrada")


class ProductMarcaArgs(BaseModel):
    product: str = Field(
        ...,
        description="Nombre del producto a buscar (ej. 'mantequilla', 'aceite').",
    )
    marca: str = Field(
        ...,
        description="Marca espec√≠fica a filtrar (ej. 'Anchor', 'Lyncott', 'Pr√©sident').",
    )


def _tool_buscar_proveedores_marca(product: str, marca: str) -> str:
    """
    Llama a la b√∫squeda filtrando por marca espec√≠fica.
    √ötil cuando el usuario ha especificado preferencia por una marca.
    """
    global _proveedores_pendientes
    
    logger.info(f"üîß TOOL LLAMADA: buscar_proveedores_marca(product='{product}', marca='{marca}')")
    logger.debug(f"üîç Iniciando b√∫squeda con filtro de marca: '{marca}' para producto: '{product}'")
    
    rows, nivel_relevancia, _ = buscar_proveedores_con_relevancia(
        product=product, 
        marca_filtro=marca
    )
    
    logger.info(f"üìä Nivel de relevancia detectado: '{nivel_relevancia}' | Marca: '{marca}'")
    logger.info(f"üìà Total de proveedores encontrados: {len(rows)}")
    
    # CASO 3: Producto fuera del sector gastron√≥mico
    if nivel_relevancia == "nula":
        logger.warning(f"‚ùå Producto '{product}' marca '{marca}' fuera del sector o sin resultados")
        resultado = {
            "nivel_relevancia": "nula",
            "mensaje": f"No encontr√© '{product}' de la marca '{marca}' en nuestro cat√°logo.",
            "proveedores": [],
            "contexto_precios": []
        }
        logger.debug(f"üì§ JSON resultado: {json.dumps(resultado, ensure_ascii=False)}")
        return json.dumps(resultado, ensure_ascii=False)
    
    # Si no hay resultados con esta marca espec√≠fica
    if not rows:
        logger.warning(f"‚ö†Ô∏è No se encontraron productos de marca '{marca}' para '{product}'")
        resultado = {
            "nivel_relevancia": "nula",
            "mensaje": f"No encontr√© '{product}' de la marca '{marca}'. ¬øQuieres ver otras marcas disponibles?",
            "proveedores": [],
            "contexto_precios": []
        }
        logger.debug(f"üì§ JSON resultado: {json.dumps(resultado, ensure_ascii=False)}")
        return json.dumps(resultado, ensure_ascii=False)
    
    # CASO 2: Producto gastron√≥mico pero no registrado (ofrecer similares)
    if nivel_relevancia == "media":
        logger.info(f"‚ö° Producto '{product}' marca '{marca}' no registrado, ofreciendo {len(rows)} similares")
        
        max_inicial = 3
        rows_mostrados = rows[:max_inicial]
        rows_ocultos = rows[max_inicial:]
        
        key_pendiente = f"{product}_{marca}".lower()
        logger.debug(f"‚úÇÔ∏è  Dividiendo resultados: {len(rows_mostrados)} mostrados, {len(rows_ocultos)} ocultos")
        logger.debug(f"üóÉÔ∏è  Key para pendientes: '{key_pendiente}'")
        
        _proveedores_pendientes[key_pendiente] = rows_ocultos
        
        if rows_ocultos:
            logger.info(f"üíæ Guardados {len(rows_ocultos)} proveedores similares para 'mostrar_mas'")
        
        # Incluir contexto_precios para que el LLM pueda usarlo si se solicita
        meta = []
        for idx, r in enumerate(rows_mostrados):
            logger.debug(f"üì¶ Proveedor {idx+1}: {r['proveedor']} (ID: {r['proveedor_id']}, Rank: {r['rank']})")
            if r.get("contexto_precios"):
                logger.debug(f"   ‚îî‚îÄ Precios disponibles: {len(r['contexto_precios'])} items")
            meta.append({
                "rank": r["rank"],
                "proveedor_id": r["proveedor_id"],
                "proveedor": r["proveedor"],
                "ejemplos": r["ejemplos"],
                "contexto_precios": r.get("contexto_precios", []),
            })
        
        resultado = {
            "nivel_relevancia": "media",
            "mensaje": f"El producto '{product}' marca '{marca}' no est√° exactamente, pero encontr√© similares.",
            "proveedores_mostrados": len(rows_mostrados),
            "proveedores_ocultos": len(rows_ocultos),
            "proveedores": meta,
            "marca_solicitada": marca
        }
        logger.info(f"‚úÖ Retornando {len(meta)} proveedores similares al LLM")
        logger.debug(f"üì§ JSON resultado: {json.dumps(resultado, ensure_ascii=False)[:200]}...")
        return json.dumps(resultado, ensure_ascii=False)
    
    # CASO 1: Alta relevancia (producto encontrado con marca espec√≠fica)
    if nivel_relevancia == "alta":
        logger.info(f"‚úÖ Producto '{product}' marca '{marca}' encontrado: {len(rows)} proveedores")
        
        max_inicial = 3
        rows_mostrados = rows[:max_inicial]
        rows_ocultos = rows[max_inicial:]
        
        key_pendiente = f"{product}_{marca}".lower()
        logger.debug(f"‚úÇÔ∏è  Dividiendo resultados: {len(rows_mostrados)} mostrados, {len(rows_ocultos)} ocultos")
        logger.debug(f"üóÉÔ∏è  Key para pendientes: '{key_pendiente}'")
        
        _proveedores_pendientes[key_pendiente] = rows_ocultos
        
        if rows_ocultos:
            logger.info(f"üíæ Guardados {len(rows_ocultos)} proveedores para 'mostrar_mas'")
        
        # Incluir contexto_precios para que el LLM pueda usarlo si se solicita
        meta = []
        for idx, r in enumerate(rows_mostrados):
            logger.debug(f"üì¶ Proveedor {idx+1}: {r['proveedor']} (ID: {r['proveedor_id']}, Rank: {r['rank']})")
            if r.get("contexto_precios"):
                logger.debug(f"   ‚îî‚îÄ Precios disponibles: {len(r['contexto_precios'])} items")
            meta.append({
                "rank": r["rank"],
                "proveedor_id": r["proveedor_id"],
                "proveedor": r["proveedor"],
                "ejemplos": r["ejemplos"],
                "contexto_precios": r.get("contexto_precios", []),
            })
        
        resultado = {
            "nivel_relevancia": "alta",
            "mensaje": f"Encontr√© {len(rows)} proveedores de '{product}' marca '{marca}'.",
            "proveedores_mostrados": len(rows_mostrados),
            "proveedores_ocultos": len(rows_ocultos),
            "proveedores": meta,
            "marca_solicitada": marca
        }
        logger.info(f"‚úÖ Retornando {len(meta)} proveedores de marca espec√≠fica al LLM")
        logger.debug(f"üì§ JSON resultado: {json.dumps(resultado, ensure_ascii=False)[:200]}...")
        return json.dumps(resultado, ensure_ascii=False)
    
    # Fallback
    logger.error(f"‚ö†Ô∏è  Fallback alcanzado - nivel_relevancia inesperado: '{nivel_relevancia}'")
    resultado = {
        "nivel_relevancia": "nula",
        "mensaje": "No se encontraron resultados.",
        "proveedores": [],
        "contexto_precios": []
    }
    return json.dumps(resultado, ensure_ascii=False)


buscar_proveedores_marca_tool = StructuredTool.from_function(
    func=_tool_buscar_proveedores_marca,
    name="buscar_proveedores_marca",
    description=(
        "Busca proveedores de un producto FILTRANDO por marca espec√≠fica. "
        "Requiere 'product' y 'marca'. √ösala cuando el usuario especifique una marca concreta "
        "(ej: 'Anchor', 'Lyncott', 'Pr√©sident'). Devuelve proveedores con contexto de precios."
    ),
    args_schema=ProductMarcaArgs,
)
logger.info("üîß Tool 'buscar_proveedores_marca' registrada")

TOOLS = [buscar_proveedores_tool, buscar_proveedores_marca_tool, mostrar_mas_proveedores_tool, detalle_proveedor_tool]
logger.info(f"‚úÖ Total de tools disponibles: {len(TOOLS)}")
for idx, tool in enumerate(TOOLS, 1):
    logger.debug(f"   {idx}. {tool.name}")

# ========== MODELO ==========
MODEL_NAME = os.getenv("CHAT_MODEL", "gpt-4o-mini")
logger.info(f"ü§ñ Usando modelo LLM: {MODEL_NAME}")

llm = ChatOpenAI(model=MODEL_NAME).bind_tools(TOOLS)
logger.info(f"‚úÖ LLM inicializado con {len(TOOLS)} tools vinculadas")

# ========== STATE ==========
class MessagesState(TypedDict):
    messages: Annotated[List[AnyMessage], add_messages]

logger.info("üì¶ MessagesState definido")

# ========== NODOS ==========
def assistant_node(state: MessagesState) -> dict:
    """Llama al modelo (que ya conoce las tools) y retorna el siguiente mensaje."""
    logger.info("ü§ñ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    logger.info("ü§ñ NODO: assistant_node - Invocando LLM...")
    logger.debug(f"üì• Estado recibido con {len(state['messages'])} mensaje(s)")
    
    # Log del √∫ltimo mensaje del usuario (si existe)
    if state['messages']:
        last_user_msg = None
        for msg in reversed(state['messages']):
            if hasattr(msg, 'type') and msg.type == 'human':
                last_user_msg = msg
                break
        if last_user_msg:
            logger.info(f"üí¨ √öltimo mensaje del usuario: '{last_user_msg.content}'")
    
    ai_msg = llm.invoke(state["messages"])
    
    logger.info(f"‚úÖ LLM respondi√≥")
    logger.debug(f"üìù Tipo de respuesta: {type(ai_msg).__name__}")
    
    # Log de tool calls si existen
    tool_calls = getattr(ai_msg, "tool_calls", None)
    if tool_calls:
        tool_names = [tc.get("name", "unknown") for tc in tool_calls]
        logger.info(f"üõ†Ô∏è  LLM solicit√≥ {len(tool_calls)} tool(s): {tool_names}")
        for idx, tc in enumerate(tool_calls, 1):
            logger.debug(f"   {idx}. Tool: {tc.get('name', 'unknown')}")
            logger.debug(f"      Args: {tc.get('args', {})}")
    else:
        logger.info(f"üí¨ LLM gener√≥ respuesta final (sin tool calls)")
        logger.info(f"üìÑ Respuesta completa del asistente:")
        logger.info(f"{'‚îÄ' * 60}")
        logger.info(f"{ai_msg.content}")
        logger.info(f"{'‚îÄ' * 60}")
    
    logger.info("ü§ñ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    return {"messages": [ai_msg]}

# ToolNode ejecuta autom√°ticamente cualquier tool_call del √∫ltimo AIMessage
tool_node = ToolNode(TOOLS)
logger.info("üîß ToolNode creado con las tools disponibles")

# ========== ENRUTADOR ==========
def router(state: MessagesState):
    """Si el √∫ltimo mensaje del asistente pide tools, vamos a 'tools'; si no, terminamos."""
    logger.info("üîÄ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    logger.info("üîÄ ROUTER: Determinando siguiente nodo...")
    logger.debug(f"üì• Estado con {len(state['messages'])} mensaje(s)")
    
    last = state["messages"][-1]
    logger.debug(f"üîç √öltimo mensaje: {type(last).__name__}")
    
    tool_calls = getattr(last, "tool_calls", None)
    if tool_calls:
        logger.info(f"üîß Router: dirigiendo a nodo 'tools' ({len(tool_calls)} tool call(s))")
        logger.debug(f"   Tools a ejecutar: {[tc.get('name', 'unknown') for tc in tool_calls]}")
        logger.info("üîÄ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        return "tools"
    
    logger.info("üèÅ Router: finalizando conversaci√≥n (END)")
    logger.debug("‚úÖ No hay tool calls pendientes - conversaci√≥n completa")
    logger.info("üîÄ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    return END

# ========== GRAFO ==========
logger.info("üìä Construyendo grafo de conversaci√≥n...")
graph = StateGraph(MessagesState)
graph.add_node("assistant", assistant_node)
logger.debug("   ‚úì Nodo 'assistant' agregado")
graph.add_node("tools", tool_node)
logger.debug("   ‚úì Nodo 'tools' agregado")

graph.set_entry_point("assistant")               # 1) punto de entrada
logger.debug("   ‚úì Entry point configurado: 'assistant'")
graph.add_conditional_edges("assistant", router) # 2) salto a tools o END
logger.debug("   ‚úì Conditional edges agregadas: assistant -> router")
graph.add_edge("tools", "assistant")             # 3) vuelta tras ejecutar tools
logger.debug("   ‚úì Edge agregada: tools -> assistant")

app = graph.compile()
logger.info("‚úÖ Grafo compilado exitosamente")

# ========== FUNCIONES MULTI-AGENTE ==========

def detectar_intencion(mensaje_usuario: str) -> str:
    """
    Usa el LLM como router para clasificar la intenci√≥n del usuario.
    Retorna: 'busqueda_proveedores', 'chef', 'nutriologo', 'bartender', 
             'barista', 'ingeniero_alimentos', 'fuera_alcance'
    """
    logger.info(f"üîç ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    logger.info(f"üîç DETECTANDO INTENCI√ìN")
    logger.info(f"üí¨ Mensaje: '{mensaje_usuario[:80]}...'")
    
    router_llm = ChatOpenAI(model=MODEL_NAME)
    
    response = router_llm.invoke([
        ("system", SYSTEM_PROMPT_ROUTER),
        ("user", mensaje_usuario)
    ])
    
    intencion = response.content.strip().lower()
    logger.info(f"üéØ Intenci√≥n detectada: '{intencion}'")
    logger.info(f"üîç ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    
    return intencion


def responder_como_chef(mensaje: str, history: list) -> tuple[str, list]:
    """Responde como Chef con recetas breves"""
    logger.info(f"üë®‚Äçüç≥ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    logger.info(f"üë®‚Äçüç≥ AGENTE: CHEF")
    logger.debug(f"üìù Mensaje: '{mensaje[:80]}...'")
    
    llm_chef = ChatOpenAI(model=MODEL_NAME)
    response = llm_chef.invoke([
        ("system", SYSTEM_PROMPT_CHEF),
        ("user", mensaje)
    ])
    
    logger.info(f"‚úÖ Chef respondi√≥: {len(response.content)} caracteres")
    logger.info(f"üë®‚Äçüç≥ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    
    # Actualizar historial
    new_history = history + [
        ("user", mensaje),
        ("assistant", response.content)
    ]
    
    return response.content, new_history


def responder_como_nutriologo(mensaje: str, history: list) -> tuple[str, list]:
    """Responde como Nutri√≥logo con info nutricional"""
    logger.info(f"ü•ó ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    logger.info(f"ü•ó AGENTE: NUTRI√ìLOGO")
    logger.debug(f"üìù Mensaje: '{mensaje[:80]}...'")
    
    llm_nutri = ChatOpenAI(model=MODEL_NAME)
    response = llm_nutri.invoke([
        ("system", SYSTEM_PROMPT_NUTRIOLOGO),
        ("user", mensaje)
    ])
    
    logger.info(f"‚úÖ Nutri√≥logo respondi√≥: {len(response.content)} caracteres")
    logger.info(f"ü•ó ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    
    new_history = history + [
        ("user", mensaje),
        ("assistant", response.content)
    ]
    
    return response.content, new_history


def responder_como_bartender(mensaje: str, history: list) -> tuple[str, list]:
    """Responde como Bartender con c√≥cteles"""
    logger.info(f"üçπ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    logger.info(f"üçπ AGENTE: BARTENDER")
    logger.debug(f"üìù Mensaje: '{mensaje[:80]}...'")
    
    llm_bartender = ChatOpenAI(model=MODEL_NAME)
    response = llm_bartender.invoke([
        ("system", SYSTEM_PROMPT_BARTENDER),
        ("user", mensaje)
    ])
    
    logger.info(f"‚úÖ Bartender respondi√≥: {len(response.content)} caracteres")
    logger.info(f"üçπ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    
    new_history = history + [
        ("user", mensaje),
        ("assistant", response.content)
    ]
    
    return response.content, new_history


def responder_como_barista(mensaje: str, history: list) -> tuple[str, list]:
    """Responde como Barista con t√©cnicas de caf√©"""
    logger.info(f"‚òï ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    logger.info(f"‚òï AGENTE: BARISTA")
    logger.debug(f"üìù Mensaje: '{mensaje[:80]}...'")
    
    llm_barista = ChatOpenAI(model=MODEL_NAME)
    response = llm_barista.invoke([
        ("system", SYSTEM_PROMPT_BARISTA),
        ("user", mensaje)
    ])
    
    logger.info(f"‚úÖ Barista respondi√≥: {len(response.content)} caracteres")
    logger.info(f"‚òï ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    
    new_history = history + [
        ("user", mensaje),
        ("assistant", response.content)
    ]
    
    return response.content, new_history


def responder_como_ingeniero(mensaje: str, history: list) -> tuple[str, list]:
    """Responde como Ingeniero en Alimentos con conservaci√≥n"""
    logger.info(f"üî¨ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    logger.info(f"üî¨ AGENTE: INGENIERO EN ALIMENTOS")
    logger.debug(f"üìù Mensaje: '{mensaje[:80]}...'")
    
    llm_ingeniero = ChatOpenAI(model=MODEL_NAME)
    response = llm_ingeniero.invoke([
        ("system", SYSTEM_PROMPT_INGENIERO),
        ("user", mensaje)
    ])
    
    logger.info(f"‚úÖ Ingeniero respondi√≥: {len(response.content)} caracteres")
    logger.info(f"üî¨ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    
    new_history = history + [
        ("user", mensaje),
        ("assistant", response.content)
    ]
    
    return response.content, new_history


def responder_fuera_alcance(mensaje: str, history: list) -> tuple[str, list]:
    """Responde cuando la pregunta est√° fuera de alcance"""
    logger.warning(f"‚ö†Ô∏è ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    logger.warning(f"‚ö†Ô∏è  PREGUNTA FUERA DE ALCANCE")
    logger.debug(f"üìù Mensaje: '{mensaje[:80]}...'")
    
    respuesta = (
        "Entiendo tu frustraci√≥n y lamento no poder ayudarte con esa consulta.\n\n"
        "Si quieres hacer una queja o sugerencia sobre nuestros servicios, "
        f"puedes enviarla a nuestro buz√≥n de quejas: {BUZON_QUEJAS}\n\n"
    )
    
    logger.info(f"‚úÖ Respuesta fuera de alcance enviada")
    logger.warning(f"‚ö†Ô∏è ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    
    new_history = history + [
        ("user", mensaje),
        ("assistant", respuesta)
    ]
    
    return respuesta, new_history

# ========== CLI DEMO ==========
def main():
    logger.info("=" * 60)
    logger.info("üöÄ Chat demo iniciado - The Hap & D Company (Multi-Agente)")
    logger.info("=" * 60)
    logger.info(f"ü§ñ Modelo: {MODEL_NAME}")
    logger.info(f"üîß Tools disponibles: {len(TOOLS)}")
    logger.info(f"üìß Buz√≥n de quejas: {BUZON_QUEJAS}")
    logger.info(f"üé≠ Roles disponibles: Buscador, Chef, Nutri√≥logo, Bartender, Barista, Ingeniero")
    logger.info("=" * 60)
    
    print("Chat demo. Escribe 'salir' para terminar.")
    # Historial con system prompt
    history = [("system", SYSTEM_PROMPT)]
    logger.info("üìã Historial inicializado con system prompt")
    
    turn_number = 0
    while True:
        q = input("> ").strip()
        if not q:
            continue
        if q.lower() in {"salir", "exit", "quit"}:
            logger.info("üëã Usuario finaliz√≥ la sesi√≥n")
            logger.info("=" * 60)
            break
        
        turn_number += 1
        logger.info(f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        logger.info(f"üí¨ TURNO {turn_number} - Usuario: {q}")
        logger.info(f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        
        # PASO 1: Detectar intenci√≥n del usuario
        intencion = detectar_intencion(q)
        
        # PASO 2: Rutear seg√∫n la intenci√≥n detectada
        if intencion == "busqueda_proveedores":
            # Flujo normal con tools (b√∫squeda de proveedores)
            logger.info(f"üîç Ruta: B√öSQUEDA DE PROVEEDORES (con tools)")
            history.append(("user", q))
            out = app.invoke({"messages": history})
            last = out["messages"][-1]
            print(last.content)
            history = out["messages"]
            
        elif intencion == "chef":
            # Agente Chef
            logger.info(f"üë®‚Äçüç≥ Ruta: CHEF (recetas y preparaci√≥n)")
            respuesta, history = responder_como_chef(q, history)
            print(respuesta)
            
        elif intencion == "nutriologo":
            # Agente Nutri√≥logo
            logger.info(f"ü•ó Ruta: NUTRI√ìLOGO (informaci√≥n nutricional)")
            respuesta, history = responder_como_nutriologo(q, history)
            print(respuesta)
            
        elif intencion == "bartender":
            # Agente Bartender
            logger.info(f"üçπ Ruta: BARTENDER (c√≥cteles y bebidas)")
            respuesta, history = responder_como_bartender(q, history)
            print(respuesta)
            
        elif intencion == "barista":
            # Agente Barista
            logger.info(f"‚òï Ruta: BARISTA (t√©cnicas de caf√©)")
            respuesta, history = responder_como_barista(q, history)
            print(respuesta)
            
        elif intencion == "ingeniero_alimentos":
            # Agente Ingeniero en Alimentos
            logger.info(f"üî¨ Ruta: INGENIERO EN ALIMENTOS (conservaci√≥n)")
            respuesta, history = responder_como_ingeniero(q, history)
            print(respuesta)
            
        elif intencion == "fuera_alcance":
            # Respuesta para temas fuera del sector gastron√≥mico
            logger.warning(f"‚ö†Ô∏è  Ruta: FUERA DE ALCANCE")
            respuesta, history = responder_fuera_alcance(q, history)
            print(respuesta)
            
        else:
            # Fallback si el router devuelve algo inesperado
            logger.error(f"‚ùå Intenci√≥n desconocida: '{intencion}'")
            respuesta = "Disculpa, no entend√≠ tu consulta. ¬øPuedes reformularla? üòä"
            print(respuesta)
            history.append(("user", q))
            history.append(("assistant", respuesta))
        
        logger.info(f"‚úÖ TURNO {turn_number} completado")
        logger.debug(f"üìö Historial actualizado: {len(history)} mensajes totales")
        logger.info(f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")

logger.info("üì¶ M√≥dulo chatbot.py cargado completamente")

if __name__ == "__main__":
    main()